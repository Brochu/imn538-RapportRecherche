%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Méthode Choisie}
\label{sect:choisie}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La technique utilsée ici se base sur les grammaires de formes. La première partie de ce rapport se penche plus précisément sur le fonctionnement de base d'une grammaire. Cette technique ,comparée aux deux autres présentées au cours de ce rapport, génère les détails des bâtiments de façon géométrique par opposition aux nuanceurs. Il est donc possible de vérifier s'il existe des intersection entre les détails générés et les annuler puisque ces intersections enlèvent beaucoup de réalisme à une scène. Pour la deuxième technique présentée, l'avantage ici est que cette technique permet la création de grands environnements en gardant un temps d'exécution raisonnable. On présente donc quelques éléments de base sur lesquels l'algorithme est basé et plus tard, on montre les différentes étapes de l'algorithme plus en détail.

\subsection{Théorie}
\label{ssect:theorie}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Une grammaire}
Dans le domaine informatique, une grammaire est définie par deux ensembles de symboles, un ensemble de règles et un symbole de départ. Le but d'une grammaire est de passer du symbole de départ et utiliser les règles pour passer à un état où il n'y a que des symboles terminaux~\cite{CtxFreeGram}. Le premier ensemble de symbole sont les symboles terminaux. Ces symboles servent à marquer la fin d'une série de changements sur un symbole. Un symbole terminal ne sera plus modifié par les règles de la grammaire. Ensuite, il y a l'ensemble des symboles non-terminaux. Ces symboles représentent des état transitifs qui seront modifiés lors de des itérations d'exécution de la grammaire. Pour finir, on définit les règles de la grammaires. Ces règles ont un format spécifique: non-terminal $\rightarrow$ serie de terminaux et non terminaux. Cette règle commence par annoncer sur quel symbole non-terminal il va agir et en quoi ce symbole sera transformé. On applique itérativement une règle à la fois sur la chaine de symbole courante jusqu'à obtenir une chaîne qui n'a que des symboles terminaux.

\subsubsection{Une grammaire de forme}
Dans le domaine de génération procédurale de bâtiment, on utilise la même idée de base mais on adapte les principes au rendu 3D. Par exemple, les symboles terminaux et non-terminaux sont des formes de base~\cite{ShapeGram}. Aussi, les règles donnent les transformation géométriques qu'il faut faire et les formes qu'il faut ajouter pour obtenir une forme terminale pour terminer l'exécution de la grammaire de forme. Voici quelques exemples de règles dans une grammarie de forme~\cite{MainArticle}:
$$ A \rightarrow [ T(0,0,6) S(8,10,18) I("cube") ] T(6,0,0) S(7,13,18) I("cube") T(0,0,16) S(8,15,8) I("cylinder") $$
$$ fac \rightarrow Subdiv("Y",3.5,0.3,3,3,3) \{ floor | ledge | floor | floor | floor \} $$
On peut aussi spécifier des règles pour créer des sous-sections de formes géometriques. Généralement, on donne une séries de longeurs (les différentes séparations) et sur quel axe (x, y ou z) on fait la séparation. On peut utiliser ces séparation pour créer des détails sur les façades des bâtiments qu'on génère en insérant d'autres modèles alignés sur ces séparations.

\subsubsection{Les portées}
Un autre élément important de l'algorithme utilisé pour cette technique sont les portées. Une portée est une partie de l'espace 3D. Les transformations spécifiées dans les règles de production sont affectées sur les portées~\cite{MainArticle}. Après les transformations géométriques, si on insère un nouveau modèle, il sera placé dans la portée et prendra la dimension et la position de la portée. On sait donc que chaque forme dans une configuration de l'algorithme possède une portée. De plus, il existe aussi une utilité pour des portées qui représentent un espace 2D. Ces portées peuvent être utilisées pour générer un toit sur un bâtiment de base. On défini une portée en 2D aligné sur un des murs du bâtiment ou le dessus de la forme et on applique des transformations et on insère des nouvelles formes pour obtenir un toit sur notre structure de base.

\subsubsection{L'algorithme}
Pour commencer, une configuration est le nom qu'on donne à un nombre fini de formes dans l'espace 3D. Aussi, dans notre cas, un symbole est représenté par une forme et ces symboles peuvent être soit non-terminaux ou terminaux. La définition plus précise des symboles se trouve plus haut dans ce document. Au départ l'algorithme doit recevoir une spécification d'un axiome qui est une configuration de formes simples pour démarrer la génération. On procède ensuite par étapes~\cite{MainArticle}: 

\begin{enumerate}
	\item On sélectionne une forme (état) non-terminale qui est toujours active. À titre d'exemple, ce symbole est nommé n
	\item On choisit ensuite une règle de production de la grammaire de forme à appliquer. Il faut que cette règle soit composée du symbole n comme partie gauche. Après on génère (à partir de la spécification de la règle choisie) un nouvel ensemble de formes. On nomme ce nouvel ensemble nNew
	\item On place la forme n comme inactive dans la liste des formes de la configuration courante. Pour finir on ajoute l'ensemble de formes nNew à la configuration et on recommence à l'étapte no.1.
\end{enumerate}

\subsection{Exemples}
\label{ssect:ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Les possibilités de génération sont pratiquement infinie. L'article étudié se penche plus en détails sur types d'exemples. Les trois premiers exemples montrés dans l'article sont volontairement simples pour montrer la base de l'algorithme. Ils montrent 3 types de constructions: une maison simple, un bloc d'édifices à bureaux et une maison un peu plus poussée. Par après, les exemples montrés sont plus complexes et montrent une utilisation plus poussée de l'algorithme. Le premier exemple plus complexe est une extension du 3e exemple qui assemble plusieurs éléments pour créer un quartier de banlieue. Ensuite, le dernier exemple de l'article montre la génération d'une ville entière basée sur le style de Pompeii.

\subsubsection{Exemple 1}

\begin{figure}[h]
    \caption{Une maison simple~\cite{MainArticle}}
    \centering

    \includegraphics[width=7cm]{simpleEx.png}
    \label{simpEx}
\end{figure}

Cet exemple montre la façon de créer la structure la plus simple avec cet algorithme pour le corps principal de la maison et la forme la plus simple de toits. Les murs sont simplement construit à partir d'une forme deux dimensions avec laquelle une extrusion a été faite pour obtenir un prisme en trois dimensions. Pour ce qui est du toit, il est construit à partir deux 2 plans en 2D qui se rencontrent au milieu du prisme de la structure du bâtiment.

\subsubsection{Exemple 2}

\begin{figure}[h]
    \caption{Un bloc d'édifices a bureaux~\cite{MainArticle}}
    \centering

    \includegraphics[width=7cm]{blocEx.png}
    \label{blocEx}
\end{figure}

Cet exemple tente de montrer qu'il est possible de générer plus qu'un seul bâtiment à la fois à l'aide de cet algorithme. L'algorithme utilise encore des formes 2D comme une base et l'extrusion de ces formes donne la forme générale des bâtiments. La distribution des formes 2D au départ définissent la densité de la ville que l'on veut obtenir. Par exemple, dans la figure~\ref{blocEx} il y a une grande densité de grand bâtiments. Aucun détails n'a été générer sur les façades des bâtiments dans cet exemple puisque les détails seront montrés dans les exemples suivants.

\subsubsection{Exemple 3}

\begin{figure}[h]
    \caption{Une maison de banlieue plus évoluée~\cite{MainArticle}}
    \centering

    \includegraphics[width=7cm]{banEx.png}
    \includegraphics[width=7cm]{groupEx.png}
    \label{groupEx}
\end{figure}

Dans cet exemple, on ajoute des détails autour de la maison. Par exemple, on ajoute une cour, un stationnement, et de la végétation. Ces détails sont générés de la même façon que les éléments de base. On ajoute aussi des trottoirs autour de la propriété.

On peut aussi utiliser plusieurs maisons de ce type et les rassembler pour créer un quartier de banlieue (figure~\ref{groupEx}). Ce rassemblement ne veut pas seulement dire qu'on execute plusieurs fois l'algorithme et qu'on combine les modèles résultants en un seul. On peut tout simplement modifier les règles de l'algorithme pour faire en sorte qu'il soit possible de générer plus qu'un seul bâtiment, mais conserver les règles qui ajoutent des détails de végétation et des trottoirs. De la même façon, on peut générer une ville plus grande en utilisant les règles de l'exemple 2 comme une base.

% \subsection{Outil Existant}
% \label{ssect:outil}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Il existe un outils qui fait usage de la technique décrite dans l'article. Cet outils s'apelle CityEngine. On remarque beaucoup des principes présenté dans l'article dans le vidéo d'introduction de l'outil[reference].
